import { useMemo, useState } from "react";
import {
  useApprovedThirdPartyPlaces,
  useHotelPlaces,
  useApproveHotelPlace,
  useRejectHotelPlace,
  useToggleHotelRecommended,
} from "../../../../../hooks/third-party-management";
import { useCurrentUserHotel } from "../../../../../hooks/useCurrentUserHotel";
import { filterPlacesByDistance } from "../../../../../utils/distance";

type Category = "gastronomy" | "tours" | "wellness";

interface Place {
  id: string;
  name: string;
  latitude: number;
  longitude: number;
  category: string;
  formatted_address?: string;
  vicinity?: string;
  rating?: number | null;
  hotel_approved?: boolean;
  hotel_recommended?: boolean;
}

interface UsePlacesTableOptions {
  category: Category;
  searchValue?: string;
}

/**
 * Custom hook to handle all the logic for places tables
 * Shared across gastronomy, tours, and wellness tabs
 */
export function usePlacesTable({
  category,
  searchValue = "",
}: UsePlacesTableOptions) {
  // Get current hotel with location
  const { data: hotelInfo } = useCurrentUserHotel();
  const hotelId = hotelInfo?.hotelId || null;

  // Distance filter state
  const [maxDistance, setMaxDistance] = useState(999999); // Default: any distance

  // Action filter state
  const [actionFilter, setActionFilter] = useState("all");

  // Sorting state
  const [sortColumn, setSortColumn] = useState<string>("");
  const [sortDirection, setSortDirection] = useState<"asc" | "desc">("asc");

  // Modal states
  const [selectedPlace, setSelectedPlace] = useState<Place | null>(null);
  const [isDetailsModalOpen, setIsDetailsModalOpen] = useState(false);
  const [isMapModalOpen, setIsMapModalOpen] = useState(false);

  // Fetch Elvira-approved places
  const { data: places, isLoading } = useApprovedThirdPartyPlaces(category);

  // Fetch hotel's relationship with places
  const { data: hotelPlaces } = useHotelPlaces(hotelId || undefined, category);

  // Mutations for hotel actions
  const approvePlace = useApproveHotelPlace();
  const rejectPlace = useRejectHotelPlace();
  const toggleRecommended = useToggleHotelRecommended();

  // Create a map of place ID to hotel relationship status
  const hotelPlaceMap = useMemo(() => {
    const map = new Map();
    hotelPlaces?.forEach((hp: { thirdparty_place_id: string; hotel_approved: boolean; hotel_recommended: boolean }) => {
      map.set(hp.thirdparty_place_id, {
        approved: hp.hotel_approved,
        recommended: hp.hotel_recommended,
      });
    });
    return map;
  }, [hotelPlaces]);

  // Filter places based on search and distance, and enrich with hotel relationship status
  const filteredPlaces = useMemo(() => {
    if (!places) return [];

    let filtered = places;

    // Apply distance filter if hotel has location
    if (
      hotelInfo?.hotel?.latitude &&
      hotelInfo?.hotel?.longitude &&
      maxDistance !== 999999
    ) {
      filtered = filterPlacesByDistance(
        filtered,
        hotelInfo.hotel.latitude,
        hotelInfo.hotel.longitude,
        maxDistance
      );
    }

    // Apply search filter
    if (searchValue) {
      const searchLower = searchValue.toLowerCase();
      filtered = filtered.filter((place) => {
        return (
          place.name.toLowerCase().includes(searchLower) ||
          place.formatted_address?.toLowerCase().includes(searchLower) ||
          place.vicinity?.toLowerCase().includes(searchLower)
        );
      });
    }

    // Enrich places with hotel relationship status
    const enriched = filtered.map((place) => {
      const hotelStatus = hotelPlaceMap.get(place.id);
      return {
        ...place,
        hotel_approved: hotelStatus?.approved || false,
        hotel_recommended: hotelStatus?.recommended || false,
      };
    });

    // Apply action filter
    let actionFiltered = enriched;
    if (actionFilter === "approved") {
      actionFiltered = enriched.filter((place) => place.hotel_approved);
    } else if (actionFilter === "not_approved") {
      actionFiltered = enriched.filter((place) => !place.hotel_approved);
    } else if (actionFilter === "recommended") {
      actionFiltered = enriched.filter((place) => place.hotel_recommended);
    }

    // Apply sorting
    if (sortColumn) {
      actionFiltered = [...actionFiltered].sort((a, b) => {
        const aValue = a[sortColumn as keyof typeof a];
        const bValue = b[sortColumn as keyof typeof b];

        // Handle null/undefined values
        if (aValue == null && bValue == null) return 0;
        if (aValue == null) return sortDirection === "asc" ? 1 : -1;
        if (bValue == null) return sortDirection === "asc" ? -1 : 1;

        // Compare values
        if (aValue < bValue) return sortDirection === "asc" ? -1 : 1;
        if (aValue > bValue) return sortDirection === "asc" ? 1 : -1;
        return 0;
      });
    }

    return actionFiltered;
  }, [
    places,
    searchValue,
    hotelInfo?.hotel?.latitude,
    hotelInfo?.hotel?.longitude,
    maxDistance,
    hotelPlaceMap,
    actionFilter,
    sortColumn,
    sortDirection,
  });

  // Calculate statistics based on filtered places
  const statistics = useMemo(() => {
    const totalPlaces = filteredPlaces.length;
    const approvedPlaces = filteredPlaces.filter(
      (p) => p.hotel_approved
    ).length;
    const recommendedPlaces = filteredPlaces.filter(
      (p) => p.hotel_recommended
    ).length;

    // Calculate average rating from places with ratings
    const placesWithRating = filteredPlaces.filter(
      (p) => p.rating != null && p.rating > 0
    ) as Array<Place & { rating: number }>;
    const averageRating =
      placesWithRating.length > 0
        ? placesWithRating.reduce((sum, p) => sum + p.rating, 0) /
          placesWithRating.length
        : 0;

    return {
      totalPlaces,
      approvedPlaces,
      recommendedPlaces,
      averageRating,
    };
  }, [filteredPlaces]);

  // Handlers
  const handleRowClick = (place: Place) => {
    setSelectedPlace(place);
    setIsDetailsModalOpen(true);
  };

  const handleSort = (column: string) => {
    if (sortColumn === column) {
      // Toggle direction if same column
      setSortDirection(sortDirection === "asc" ? "desc" : "asc");
    } else {
      // Set new column and default to asc
      setSortColumn(column);
      setSortDirection("asc");
    }
  };

  const handleApprove = async (placeId: string) => {
    if (!hotelId) return;
    await approvePlace.mutateAsync({
      hotelId,
      placeId,
    });
  };

  const handleReject = async (placeId: string) => {
    if (!hotelId) return;
    await rejectPlace.mutateAsync({
      hotelId,
      placeId,
    });
  };

  const handleToggleRecommended = async (placeId: string) => {
    if (!hotelId) return;
    const currentStatus = hotelPlaceMap.get(placeId);
    await toggleRecommended.mutateAsync({
      hotelId,
      placeId,
      recommended: !currentStatus?.recommended,
    });
  };

  return {
    // Data
    places: filteredPlaces,
    isLoading,
    hotelPlaceMap,
    hotelInfo,
    hotelId,
    statistics,

    // Filter state
    maxDistance,
    setMaxDistance,
    actionFilter,
    setActionFilter,

    // Sorting state
    sortColumn,
    sortDirection,

    // Modal state
    selectedPlace,
    isDetailsModalOpen,
    setIsDetailsModalOpen,
    isMapModalOpen,
    setIsMapModalOpen,

    // Handlers
    handleRowClick,
    handleApprove,
    handleReject,
    handleToggleRecommended,
    handleSort,
  };
}
